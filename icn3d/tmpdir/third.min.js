var $NGL_shaderTextHash={};$NGL_shaderTextHash["SphereImpostor.frag"]=["#define STANDARD","#define IMPOSTOR","","uniform vec3 diffuse;","uniform vec3 emissive;","uniform float roughness;","uniform float metalness;","uniform float opacity;","uniform float nearClip;","uniform mat4 projectionMatrix;","uniform float ortho;","","varying float vRadius;","varying float vRadiusSq;","varying vec3 vPoint;","varying vec3 vPointViewPosition;","","#ifdef PICKING","    uniform float objectId;","    varying vec3 vPickingColor;","#else","    #include common","    #include color_pars_fragment","    #include fog_pars_fragment","    #include bsdfs","    #include lights_pars_begin","    #include lights_physical_pars_fragment","#endif","","bool flag2 = false;","bool interior = false;","vec3 cameraPos;","vec3 cameraNormal;","","// Calculate depth based on the given camera position.","float calcDepth( in vec3 cameraPos ){","    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;","    return 0.5 + 0.5 * clipZW.x / clipZW.y;","}","","float calcClip( vec3 cameraPos ){","    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );","}","","bool Impostor( out vec3 cameraPos, out vec3 cameraNormal ){","","    vec3 cameraSpherePos = -vPointViewPosition;","    cameraSpherePos.z += vRadius;","","    vec3 rayOrigin = mix( vec3( 0.0, 0.0, 0.0 ), vPoint, ortho );","    vec3 rayDirection = mix( normalize( vPoint ), vec3( 0.0, 0.0, 1.0 ), ortho );","    vec3 cameraSphereDir = mix( cameraSpherePos, rayOrigin - cameraSpherePos, ortho );","","    float B = dot( rayDirection, cameraSphereDir );","    float det = B * B + vRadiusSq - dot( cameraSphereDir, cameraSphereDir );","","    if( det < 0.0 ){","        discard;","        return false;","    }","        float sqrtDet = sqrt( det );","        float posT = mix( B + sqrtDet, B + sqrtDet, ortho );","        float negT = mix( B - sqrtDet, sqrtDet - B, ortho );","","        cameraPos = rayDirection * negT + rayOrigin;","","        #ifdef NEAR_CLIP","if( calcDepth( cameraPos ) <= 0.0 ){","    cameraPos = rayDirection * posT + rayOrigin;","    interior = true;","    return false;","}else if( calcClip( cameraPos ) > 0.0 ){","    cameraPos = rayDirection * posT + rayOrigin;","    interior = true;","    flag2 = true;","    return false;","}else{","    cameraNormal = normalize( cameraPos - cameraSpherePos );","}","        #else","if( calcDepth( cameraPos ) <= 0.0 ){","    cameraPos = rayDirection * posT + rayOrigin;","    interior = true;","    return false;","}else{","    cameraNormal = normalize( cameraPos - cameraSpherePos );","}","        #endif","","        cameraNormal = normalize( cameraPos - cameraSpherePos );","        cameraNormal *= float(!interior) * 2.0 - 1.0;","         return !interior;","","}","","void main(void){","","    bool flag = Impostor( cameraPos, cameraNormal );","","    #ifdef NEAR_CLIP","        if( calcClip( cameraPos ) > 0.0 )","            discard;","    #endif","","    // FIXME not compatible with custom clipping plane","    //Set the depth based on the new cameraPos.","    gl_FragDepthEXT = calcDepth( cameraPos );","    if( !flag ){","","        // clamp to near clipping plane and add a tiny value to","        // make spheres with a greater radius occlude smaller ones","        #ifdef NEAR_CLIP","if( flag2 ){","    gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );","}else if( gl_FragDepthEXT >= 0.0 ){","    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );","}","        #else","if( gl_FragDepthEXT >= 0.0 ){","    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );","}","        #endif","","    }","","    // bugfix (mac only?)","    if (gl_FragDepthEXT < 0.0)","        discard;","    if (gl_FragDepthEXT > 1.0)","        discard;","","    #ifdef PICKING","","        gl_FragColor = vec4( vPickingColor, objectId );","","    #else","","        vec3 vNormal = cameraNormal;","        vec3 vViewPosition = -cameraPos;","","        vec4 diffuseColor = vec4( diffuse, opacity );","        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","        vec3 totalEmissiveLight = emissive;","","        #include color_fragment","        #include roughnessmap_fragment","        #include metalnessmap_fragment","","        // don't use include normal_fragment","        vec3 normal = normalize( vNormal );","","        #include lights_physical_fragment","        //include lights_template","        #include lights_fragment_begin","        #include lights_fragment_end","","        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;","","        gl_FragColor = vec4( outgoingLight, diffuseColor.a );","        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );","","        #include premultiplied_alpha_fragment","        #include tonemapping_fragment","        #include encodings_fragment","        //include fog_fragment","        #ifdef USE_FOG","            #ifdef USE_LOGDEPTHBUF_EXT","                float depth = gl_FragDepthEXT / gl_FragCoord.w;","            #else","                float depth = gl_FragCoord.z / gl_FragCoord.w;","            #endif","            #ifdef FOG_EXP2","                float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );","            #else","                float fogFactor = smoothstep( fogNear, fogFar, depth );","            #endif","            gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );","        #endif","","    #endif","","}"].join("\n"),$NGL_shaderTextHash["SphereImpostor.vert"]=["uniform mat4 projectionMatrixInverse;","uniform float nearClip;","","varying float vRadius;","varying float vRadiusSq;","varying vec3 vPoint;","varying vec3 vPointViewPosition;","varying float fogDepth;","varying float fogNear;","varying float fogFar;","","attribute vec2 mapping;","//attribute vec3 position;","attribute float radius;","","#ifdef PICKING","    #include unpack_clr","    attribute float primitiveId;","    varying vec3 vPickingColor;","#else","    #include color_pars_vertex","#endif","","//include matrix_scale","float matrixScale( in mat4 m ){","    vec4 r = m[ 0 ];","    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );","}","","const mat4 D = mat4(","    1.0, 0.0, 0.0, 0.0,","    0.0, 1.0, 0.0, 0.0,","    0.0, 0.0, 1.0, 0.0,","    0.0, 0.0, 0.0, -1.0",");","","mat4 transposeTmp( in mat4 inMatrix ) {","    vec4 i0 = inMatrix[0];","    vec4 i1 = inMatrix[1];","    vec4 i2 = inMatrix[2];","    vec4 i3 = inMatrix[3];","","    mat4 outMatrix = mat4(","        vec4(i0.x, i1.x, i2.x, i3.x),","        vec4(i0.y, i1.y, i2.y, i3.y),","        vec4(i0.z, i1.z, i2.z, i3.z),","        vec4(i0.w, i1.w, i2.w, i3.w)","    );","    return outMatrix;","}","","//------------------------------------------------------------------------------","// Compute point size and center using the technique described in:","// 'GPU-Based Ray-Casting of Quadratic Surfaces'","// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.","//","// Code based on","/*=========================================================================",""," Program:   Visualization Toolkit"," Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",""," Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen"," All rights reserved."," See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",""," This software is distributed WITHOUT ANY WARRANTY; without even"," the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR"," PURPOSE.  See the above copyright notice for more information.",""," =========================================================================*/","","// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl","// .SECTION Thanks","// <verbatim>","//","//  This file is part of the PointSprites plugin developed and contributed by","//","//  Copyright (c) CSCS - Swiss National Supercomputing Centre","//                EDF - Electricite de France","//","//  John Biddiscombe, Ugo Varetto (CSCS)","//  Stephane Ploix (EDF)","//","// </verbatim>","//","// Contributions by Alexander Rose","// - ported to WebGL","// - adapted to work with quads","void ComputePointSizeAndPositionInClipCoordSphere(){","","    vec2 xbc;","    vec2 ybc;","","    mat4 T = mat4(","        radius, 0.0, 0.0, 0.0,","        0.0, radius, 0.0, 0.0,","        0.0, 0.0, radius, 0.0,","        position.x, position.y, position.z, 1.0","    );","","    mat4 R = transposeTmp( projectionMatrix * modelViewMatrix * T );","    float A = dot( R[ 3 ], D * R[ 3 ] );","    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );","    float C = dot( R[ 0 ], D * R[ 0 ] );","    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;","","    A = dot( R[ 3 ], D * R[ 3 ] );","    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );","    C = dot( R[ 1 ], D * R[ 1 ] );","    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;","","    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );","    gl_Position.xy -= mapping * vec2( sx, sy );","    gl_Position.xy *= gl_Position.w;","","}","","void main(void){","","    #ifdef PICKING","        vPickingColor = unpackColor( primitiveId );","    #else","        #include color_vertex","    #endif","","    vRadius = radius * matrixScale( modelViewMatrix );","","    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","    // avoid clipping, added again in fragment shader","    mvPosition.z -= vRadius;","","    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );","    ComputePointSizeAndPositionInClipCoordSphere();","","","    vRadiusSq = vRadius * vRadius;","    vec4 vPoint4 = projectionMatrixInverse * gl_Position;","    vPoint = vPoint4.xyz / vPoint4.w;","    vPointViewPosition = -mvPosition.xyz / mvPosition.w;","","}"].join("\n"),$NGL_shaderTextHash["CylinderImpostor.frag"]=["#define STANDARD","#define IMPOSTOR","","// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.","//","//  All Rights Reserved","//","//  Permission to use, copy, modify, distribute, and distribute modified","//  versions of this software and its built-in documentation for any","//  purpose and without fee is hereby granted, provided that the above","//  copyright notice appears in all copies and that both the copyright","//  notice and this permission notice appear in supporting documentation,","//  and that the name of Schrodinger, LLC not be used in advertising or","//  publicity pertaining to distribution of the software without specific,","//  written prior permission.","//","//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,","//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN","//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR","//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS","//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE","//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE","//  USE OR PERFORMANCE OF THIS SOFTWARE.","","// Contributions by Alexander Rose","// - ported to WebGL","// - dual color","// - pk color","// - custom clipping","// - three.js lighting","","uniform vec3 diffuse;","uniform vec3 emissive;","uniform float roughness;","uniform float metalness;","uniform float opacity;","uniform float nearClip;","uniform mat4 projectionMatrix;","uniform float ortho;","","varying vec3 axis;","varying vec4 base_radius;","varying vec4 end_b;","varying vec3 U;","varying vec3 V;","varying vec4 w;","","#ifdef PICKING","    uniform float objectId;","    varying vec3 vPickingColor;","#else","    varying vec3 vColor1;","    varying vec3 vColor2;","    #include common","    #include fog_pars_fragment","    #include bsdfs","    #include lights_pars_begin","    #include lights_physical_pars_fragment","#endif","","bool interior = false;","","float distSq3( vec3 v3a, vec3 v3b ){","    return (","        ( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +","        ( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +","        ( v3a.z - v3b.z ) * ( v3a.z - v3b.z )","    );","}","","// Calculate depth based on the given camera position.","float calcDepth( in vec3 cameraPos ){","    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;","    return 0.5 + 0.5 * clipZW.x / clipZW.y;","}","","float calcClip( vec3 cameraPos ){","    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );","}","","void main(){","","    vec3 point = w.xyz / w.w;","","    // unpacking","    vec3 base = base_radius.xyz;","    float vRadius = base_radius.w;","    vec3 end = end_b.xyz;","    float b = end_b.w;","","    vec3 end_cyl = end;","    vec3 surface_point = point;","","    vec3 ray_target = surface_point;","    vec3 ray_origin = vec3(0.0);","    vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);","    mat3 basis = mat3( U, V, axis );","","    vec3 diff = ray_target - 0.5 * (base + end_cyl);","    vec3 P = diff * basis;","","    // angle (cos) between cylinder cylinder_axis and ray direction","    float dz = dot( axis, ray_direction );","","    float radius2 = vRadius*vRadius;","","    // calculate distance to the cylinder from ray origin","    vec3 D = vec3(dot(U, ray_direction),","                dot(V, ray_direction),","                dz);","    float a0 = P.x*P.x + P.y*P.y - radius2;","    float a1 = P.x*D.x + P.y*D.y;","    float a2 = D.x*D.x + D.y*D.y;","","    // calculate a dicriminant of the above quadratic equation","    float d = a1*a1 - a0*a2;","    if (d < 0.0)","        // outside of the cylinder","        discard;","","    float dist = (-a1 + sqrt(d)) / a2;","","    // point of intersection on cylinder surface","    vec3 new_point = ray_target + dist * ray_direction;","","    vec3 tmp_point = new_point - base;","    vec3 _normal = normalize( tmp_point - axis * dot(tmp_point, axis) );","","    ray_origin = mix( ray_origin, surface_point, ortho );","","    // test caps","    float front_cap_test = dot( tmp_point, axis );","    float end_cap_test = dot((new_point - end_cyl), axis);","","    // to calculate caps, simply check the angle between","    // the point of intersection - cylinder end vector","    // and a cap plane normal (which is the cylinder cylinder_axis)","    // if the angle < 0, the point is outside of cylinder","    // test front cap","","    #ifndef CAP","        vec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;","        vec3 tmp_point2 = new_point2 - base;","    #endif","","    // flat","    if (front_cap_test < 0.0)","    {","        // ray-plane intersection","        float dNV = dot(-axis, ray_direction);","        if (dNV < 0.0)","            discard;","        float near = dot(-axis, (base)) / dNV;","        vec3 front_point = ray_direction * near + ray_origin;","        // within the cap radius?","        if (dot(front_point - base, front_point-base) > radius2)","            discard;","","        #ifdef CAP","            new_point = front_point;","            _normal = axis;","        #else","            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;","            dNV = dot(-axis, ray_direction);","            near = dot(axis, end_cyl) / dNV;","            new_point2 = ray_direction * near + ray_origin;","            if (dot(new_point2 - end_cyl, new_point2-base) < radius2)","                discard;","            interior = true;","        #endif","    }","","    // test end cap","","","    // flat","    if( end_cap_test > 0.0 )","    {","        // ray-plane intersection","        float dNV = dot(axis, ray_direction);","        if (dNV < 0.0)","            discard;","        float near = dot(axis, end_cyl) / dNV;","        vec3 end_point = ray_direction * near + ray_origin;","        // within the cap radius?","        if( dot(end_point - end_cyl, end_point-base) > radius2 )","            discard;","","        #ifdef CAP","            new_point = end_point;","            _normal = axis;","        #else","            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;","            dNV = dot(-axis, ray_direction);","            near = dot(-axis, (base)) / dNV;","            new_point2 = ray_direction * near + ray_origin;","            if (dot(new_point2 - base, new_point2-base) < radius2)","                discard;","            interior = true;","        #endif","    }","","    gl_FragDepthEXT = calcDepth( new_point );","","    #ifdef NEAR_CLIP","        if( calcClip( new_point ) > 0.0 ){","            dist = (-a1 - sqrt(d)) / a2;","            new_point = ray_target + dist * ray_direction;","            if( calcClip( new_point ) > 0.0 )","                discard;","            interior = true;","            gl_FragDepthEXT = calcDepth( new_point );","            if( gl_FragDepthEXT >= 0.0 ){","                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );","            }","        }else if( gl_FragDepthEXT <= 0.0 ){","            dist = (-a1 - sqrt(d)) / a2;","            new_point = ray_target + dist * ray_direction;","            interior = true;","            gl_FragDepthEXT = calcDepth( new_point );","            if( gl_FragDepthEXT >= 0.0 ){","                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );","            }","        }","    #else","        if( gl_FragDepthEXT <= 0.0 ){","            dist = (-a1 - sqrt(d)) / a2;","            new_point = ray_target + dist * ray_direction;","            interior = true;","            gl_FragDepthEXT = calcDepth( new_point );","            if( gl_FragDepthEXT >= 0.0 ){","                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );","            }","        }","    #endif","","    // this is a workaround necessary for Mac","    // otherwise the modified fragment won't clip properly","    if (gl_FragDepthEXT < 0.0)","        discard;","    if (gl_FragDepthEXT > 1.0)","        discard;","","    #ifdef PICKING","","        gl_FragColor = vec4( vPickingColor, objectId );","","    #else","","        vec3 vViewPosition = -new_point;","        vec3 vNormal = _normal;","        vec3 vColor;","","        if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){","            if( b < 0.0 ){","                vColor = vColor1;","            }else{","                vColor = vColor2;","            }","        }else{","            if( b > 0.0 ){","                vColor = vColor1;","            }else{","                vColor = vColor2;","            }","        }","","        vec4 diffuseColor = vec4( diffuse, opacity );","        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","        vec3 totalEmissiveLight = emissive;","","        #include color_fragment","     //ifdef USE_COLOR","     //diffuseColor.r *= vColor[0];","     //diffuseColor.g *= vColor[1];","     //diffuseColor.b *= vColor[2];","     //endif","        #include roughnessmap_fragment","        #include metalnessmap_fragment","","        // don't use include normal_fragment","        vec3 normal = normalize( vNormal );","","        #include lights_physical_fragment","        //include lights_template","        #include lights_fragment_begin","        #include lights_fragment_end","","        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;","","        gl_FragColor = vec4( outgoingLight, diffuseColor.a );","        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );","","        #include premultiplied_alpha_fragment","        #include tonemapping_fragment","        #include encodings_fragment","        //include fog_fragment","        #ifdef USE_FOG","            #ifdef USE_LOGDEPTHBUF_EXT","                float depth = gl_FragDepthEXT / gl_FragCoord.w;","            #else","                float depth = gl_FragCoord.z / gl_FragCoord.w;","            #endif","            #ifdef FOG_EXP2","                float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );","            #else","                float fogFactor = smoothstep( fogNear, fogFar, depth );","            #endif","            gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );","        #endif","","    #endif","","}"].join("\n"),$NGL_shaderTextHash["CylinderImpostor.vert"]=["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.","//","//  All Rights Reserved","//","//  Permission to use, copy, modify, distribute, and distribute modified","//  versions of this software and its built-in documentation for any","//  purpose and without fee is hereby granted, provided that the above","//  copyright notice appears in all copies and that both the copyright","//  notice and this permission notice appear in supporting documentation,","//  and that the name of Schrodinger, LLC not be used in advertising or","//  publicity pertaining to distribution of the software without specific,","//  written prior permission.","//","//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,","//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN","//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR","//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS","//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE","//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE","//  USE OR PERFORMANCE OF THIS SOFTWARE.","","// Contributions by Alexander Rose","// - ported to WebGL","// - dual color","// - pk color","// - shift","","attribute vec3 mapping;","attribute vec3 position1;","attribute vec3 position2;","attribute float radius;","","varying vec3 axis;","varying vec4 base_radius;","varying vec4 end_b;","varying vec3 U;","varying vec3 V;","varying vec4 w;","varying float fogDepth;","varying float fogNear;","varying float fogFar;","","#ifdef PICKING","    #include unpack_clr","    attribute float primitiveId;","    varying vec3 vPickingColor;","#else","    //attribute vec3 color;","    attribute vec3 color2;","    varying vec3 vColor1;","    varying vec3 vColor2;","#endif","","uniform mat4 modelViewMatrixInverse;","uniform float ortho;","","//include matrix_scale","float matrixScale( in mat4 m ){","    vec4 r = m[ 0 ];","    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );","}","","void main(){","","    #ifdef PICKING","        vPickingColor = unpackColor( primitiveId );","    #else","        vColor1 = color;","        vColor2 = color2;","    #endif","","    // vRadius = radius;","    base_radius.w = radius * matrixScale( modelViewMatrix );","","    //vec3 center = position;","    vec3 center = ( position2 + position1 ) / 2.0;","    vec3 dir = normalize( position2 - position1 );","    float ext = length( position2 - position1 ) / 2.0;","","    // using cameraPosition fails on some machines, not sure why","    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );","    vec3 cam_dir;","    if( ortho == 0.0 ){","        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;","    }else{","        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;","    }","    cam_dir = normalize( cam_dir );","","    vec3 ldir;","","    float b = dot( cam_dir, dir );","    end_b.w = b;","    // direction vector looks away, so flip","    if( b < 0.0 )","        ldir = -ext * dir;","    // direction vector already looks in my direction","    else","        ldir = ext * dir;","","    vec3 left = normalize( cross( cam_dir, ldir ) );","    left = radius * left;","    vec3 up = radius * normalize( cross( left, ldir ) );","","    // transform to modelview coordinates","    axis = normalize( normalMatrix * ldir );","    U = normalize( normalMatrix * up );","    V = normalize( normalMatrix * left );","","    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );","    base_radius.xyz = base4.xyz / base4.w;","","    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );","    vec4 end4 = top_position;","    end_b.xyz = end4.xyz / end4.w;","","    w = modelViewMatrix * vec4(","        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0","    );","","    gl_Position = projectionMatrix * w;","","    // avoid clipping (1.0 seems to induce flickering with some drivers)","    gl_Position.z = 0.99;","","}"].join("\n"),$NGL_shaderTextHash["SphereInstancing.frag"]=$NGL_shaderTextHash["SphereImpostor.frag"],$NGL_shaderTextHash["SphereInstancing.vert"]=["uniform mat4 projectionMatrixInverse;","uniform float nearClip;","","varying float vRadius;","varying float vRadiusSq;","varying vec3 vPoint;","varying vec3 vPointViewPosition;","varying float fogDepth;","varying float fogNear;","varying float fogFar;","","attribute vec2 mapping;","//attribute vec3 position;","attribute float radius;","attribute vec4 matrix1;","attribute vec4 matrix2;","attribute vec4 matrix3;","attribute vec4 matrix4;","","#ifdef PICKING","    #include unpack_clr","    attribute float primitiveId;","    varying vec3 vPickingColor;","#else","    #include color_pars_vertex","#endif","","//include matrix_scale","float matrixScale( in mat4 m ){","    vec4 r = m[ 0 ];","    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );","}","","const mat4 D = mat4(","    1.0, 0.0, 0.0, 0.0,","    0.0, 1.0, 0.0, 0.0,","    0.0, 0.0, 1.0, 0.0,","    0.0, 0.0, 0.0, -1.0",");","","mat4 transposeTmp( in mat4 inMatrix ) {","    vec4 i0 = inMatrix[0];","    vec4 i1 = inMatrix[1];","    vec4 i2 = inMatrix[2];","    vec4 i3 = inMatrix[3];","","    mat4 outMatrix = mat4(","        vec4(i0.x, i1.x, i2.x, i3.x),","        vec4(i0.y, i1.y, i2.y, i3.y),","        vec4(i0.z, i1.z, i2.z, i3.z),","        vec4(i0.w, i1.w, i2.w, i3.w)","    );","    return outMatrix;","}","","//------------------------------------------------------------------------------","// Compute point size and center using the technique described in:","// 'GPU-Based Ray-Casting of Quadratic Surfaces'","// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.","//","// Code based on","/*=========================================================================",""," Program:   Visualization Toolkit"," Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",""," Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen"," All rights reserved."," See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",""," This software is distributed WITHOUT ANY WARRANTY; without even"," the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR"," PURPOSE.  See the above copyright notice for more information.",""," =========================================================================*/","","// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl","// .SECTION Thanks","// <verbatim>","//","//  This file is part of the PointSprites plugin developed and contributed by","//","//  Copyright (c) CSCS - Swiss National Supercomputing Centre","//                EDF - Electricite de France","//","//  John Biddiscombe, Ugo Varetto (CSCS)","//  Stephane Ploix (EDF)","//","// </verbatim>","//","// Contributions by Alexander Rose","// - ported to WebGL","// - adapted to work with quads","void ComputePointSizeAndPositionInClipCoordSphere(vec4 updatePosition){","","    vec2 xbc;","    vec2 ybc;","","    mat4 T = mat4(","        radius, 0.0, 0.0, 0.0,","        0.0, radius, 0.0, 0.0,","        0.0, 0.0, radius, 0.0,","        updatePosition.x, updatePosition.y, updatePosition.z, 1.0","    );","","    mat4 R = transposeTmp( projectionMatrix * modelViewMatrix * T );","    float A = dot( R[ 3 ], D * R[ 3 ] );","    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );","    float C = dot( R[ 0 ], D * R[ 0 ] );","    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;","","    A = dot( R[ 3 ], D * R[ 3 ] );","    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );","    C = dot( R[ 1 ], D * R[ 1 ] );","    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );","    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;","","    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );","    gl_Position.xy -= mapping * vec2( sx, sy );","    gl_Position.xy *= gl_Position.w;","","}","","  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {","    return mat4(","      v1.x, v1.y, v1.z, v1.w,","      v2.x, v2.y, v2.z, v2.w,","      v3.x, v3.y, v3.z, v3.w,","      v4.x, v4.y, v4.z, v4.w","    );","  }","","void main(void){","","    #ifdef PICKING","        vPickingColor = unpackColor( primitiveId );","    #else","        #include color_vertex","    #endif","","    vRadius = radius * matrixScale( modelViewMatrix );","","    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);","    vec4 updatePosition = matrix * vec4(position, 1.0);","","//    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","    vec4 mvPosition = modelViewMatrix * vec4( updatePosition.xyz, 1.0 );","    // avoid clipping, added again in fragment shader","    mvPosition.z -= vRadius;","","//    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );","    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );","    ComputePointSizeAndPositionInClipCoordSphere(updatePosition);","","","    vRadiusSq = vRadius * vRadius;","    vec4 vPoint4 = projectionMatrixInverse * gl_Position;","    vPoint = vPoint4.xyz / vPoint4.w;","    vPointViewPosition = -mvPosition.xyz / mvPosition.w;","","}"].join("\n"),$NGL_shaderTextHash["CylinderInstancing.frag"]=$NGL_shaderTextHash["CylinderImpostor.frag"],$NGL_shaderTextHash["CylinderInstancing.vert"]=["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.","//","//  All Rights Reserved","//","//  Permission to use, copy, modify, distribute, and distribute modified","//  versions of this software and its built-in documentation for any","//  purpose and without fee is hereby granted, provided that the above","//  copyright notice appears in all copies and that both the copyright","//  notice and this permission notice appear in supporting documentation,","//  and that the name of Schrodinger, LLC not be used in advertising or","//  publicity pertaining to distribution of the software without specific,","//  written prior permission.","//","//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,","//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN","//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR","//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS","//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE","//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE","//  USE OR PERFORMANCE OF THIS SOFTWARE.","","// Contributions by Alexander Rose","// - ported to WebGL","// - dual color","// - pk color","// - shift","","attribute vec3 mapping;","attribute vec3 position1;","attribute vec3 position2;","attribute float radius;","attribute vec4 matrix1;","attribute vec4 matrix2;","attribute vec4 matrix3;","attribute vec4 matrix4;","","varying vec3 axis;","varying vec4 base_radius;","varying vec4 end_b;","varying vec3 U;","varying vec3 V;","varying vec4 w;","varying float fogDepth;","varying float fogNear;","varying float fogFar;","","#ifdef PICKING","    #include unpack_clr","    attribute float primitiveId;","    varying vec3 vPickingColor;","#else","    //attribute vec3 color;","    attribute vec3 color2;","    varying vec3 vColor1;","    varying vec3 vColor2;","#endif","","uniform mat4 modelViewMatrixInverse;","uniform float ortho;","","//include matrix_scale","float matrixScale( in mat4 m ){","    vec4 r = m[ 0 ];","    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );","}","","  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {","    return mat4(","      v1.x, v1.y, v1.z, v1.w,","      v2.x, v2.y, v2.z, v2.w,","      v3.x, v3.y, v3.z, v3.w,","      v4.x, v4.y, v4.z, v4.w","    );","  }","","void main(){","","    #ifdef PICKING","        vPickingColor = unpackColor( primitiveId );","    #else","        vColor1 = color;","        vColor2 = color2;","    #endif","","    // vRadius = radius;","    base_radius.w = radius * matrixScale( modelViewMatrix );","","    //vec3 center = ( position2 + position1 ) / 2.0;","","    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);","    vec4 updatePosition1 = matrix * vec4(position1, 1.0);","    vec4 updatePosition2 = matrix * vec4(position2, 1.0);","    vec3 center = ( updatePosition2.xyz + updatePosition1.xyz ) / 2.0;","","    //vec3 dir = normalize( position2 - position1 );","    vec3 dir = normalize( updatePosition2.xyz - updatePosition1.xyz );","    float ext = length( position2 - position1 ) / 2.0;","","    // using cameraPosition fails on some machines, not sure why","    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );","    vec3 cam_dir;","    if( ortho == 0.0 ){","        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;","    }else{","        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;","    }","    cam_dir = normalize( cam_dir );","","    vec3 ldir;","","    float b = dot( cam_dir, dir );","    end_b.w = b;","    // direction vector looks away, so flip","    if( b < 0.0 )","        ldir = -ext * dir;","    // direction vector already looks in my direction","    else","        ldir = ext * dir;","","    vec3 left = normalize( cross( cam_dir, ldir ) );","    left = radius * left;","    vec3 up = radius * normalize( cross( left, ldir ) );","","    // transform to modelview coordinates","    axis = normalize( normalMatrix * ldir );","    U = normalize( normalMatrix * up );","    V = normalize( normalMatrix * left );","","    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );","    base_radius.xyz = base4.xyz / base4.w;","","    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );","    vec4 end4 = top_position;","    end_b.xyz = end4.xyz / end4.w;","","    w = modelViewMatrix * vec4(","        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0","    );","","    gl_Position = projectionMatrix * w;","","    // avoid clipping (1.0 seems to induce flickering with some drivers)","    gl_Position.z = 0.99;","","}"].join("\n"),$NGL_shaderTextHash["Instancing.frag"]=["#define STANDARD","uniform vec3 diffuse;","uniform vec3 emissive;","uniform float roughness;","uniform float metalness;","uniform float opacity;","uniform float nearClip;","uniform float clipRadius;","uniform mat4 projectionMatrix;","uniform float ortho;","varying float bCylinder;","","#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )","    varying vec3 vViewPosition;","#endif","","#if defined( RADIUS_CLIP )","    varying vec3 vClipCenter;","#endif","","#if defined( PICKING )","    uniform float objectId;","    varying vec3 vPickingColor;","#elif defined( NOLIGHT )","    varying vec3 vColor;","#else","    #ifndef FLAT_SHADED","        varying vec3 vNormal;","    #endif","    #include common","    #include color_pars_fragment","    #include fog_pars_fragment","    #include bsdfs","    #include lights_pars_begin","    #include lights_physical_pars_fragment","#endif","","void main(){","    #include nearclip_fragment","    #include radiusclip_fragment","","    #if defined( PICKING )","","        gl_FragColor = vec4( vPickingColor, objectId );","","    #elif defined( NOLIGHT )","","        gl_FragColor = vec4( vColor, opacity );","","    #else","","        vec4 diffuseColor = vec4( diffuse, opacity );","        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","        vec3 totalEmissiveLight = emissive;","","        #include color_fragment","        #include roughnessmap_fragment","        #include metalnessmap_fragment","        #include normal_flip","        #include normal_fragment_begin","","        //include dull_interior_fragment","","        #include lights_physical_fragment","        //include lights_template","        #include lights_fragment_begin","        #include lights_fragment_end","","        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;","","        #include interior_fragment","","        gl_FragColor = vec4( outgoingLight, diffuseColor.a );","","        #include premultiplied_alpha_fragment","        #include tonemapping_fragment","        #include encodings_fragment","        #include fog_fragment","","        #include opaque_back_fragment","","    #endif","","}"].join("\n"),$NGL_shaderTextHash["Instancing.vert"]=["#define STANDARD","","uniform mat4 projectionMatrixInverse;","uniform float nearClip;","uniform vec3 clipCenter;","attribute vec4 matrix1;","attribute vec4 matrix2;","attribute vec4 matrix3;","attribute vec4 matrix4;","attribute float cylinder;","varying float bCylinder;","","#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )","    varying vec3 vViewPosition;","#endif","","#if defined( RADIUS_CLIP )","    varying vec3 vClipCenter;","#endif","","#if defined( PICKING )","    #include unpack_color","    attribute float primitiveId;","    varying vec3 vPickingColor;","#elif defined( NOLIGHT )","    varying vec3 vColor;","#else","    #include color_pars_vertex","    #ifndef FLAT_SHADED","        varying vec3 vNormal;","    #endif","#endif","","#include common","","  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {","    return mat4(","      v1.x, v1.y, v1.z, v1.w,","      v2.x, v2.y, v2.z, v2.w,","      v3.x, v3.y, v3.z, v3.w,","      v4.x, v4.y, v4.z, v4.w","    );","  }","","void main(){","    bCylinder = cylinder;","","    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);","    vec4 updatePosition = matrix * vec4(position, 1.0);","","    #if defined( PICKING )","        vPickingColor = unpackColor( primitiveId );","    #elif defined( NOLIGHT )","        vColor = color;","    #else","        #include color_vertex","        //include beginnormal_vertex","        //vec3 objectNormal = vec3( normal );","        vec3 objectNormal = vec3(matrix * vec4(normal,0.0));","        #include defaultnormal_vertex","        // Normal computed with derivatives when FLAT_SHADED","        #ifndef FLAT_SHADED","            vNormal = normalize( transformedNormal );","        #endif","    #endif","","    //include begin_vertex","    vec3 transformed = updatePosition.xyz;","    //include project_vertex","    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );","    gl_Position = projectionMatrix * mvPosition;","","    #if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )","        vViewPosition = -mvPosition.xyz;","    #endif","","    #if defined( RADIUS_CLIP )","        vClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;","    #endif","","    #include nearclip_vertex","","}"].join("\n"),THREE.RenderableObject=function(){"use strict";this.id=0,this.object=null,this.z=0},THREE.RenderableFace=function(){"use strict";this.id=0,this.v1=new THREE.RenderableVertex,this.v2=new THREE.RenderableVertex,this.v3=new THREE.RenderableVertex,this.normalModel=new THREE.Vector3,this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],this.vertexNormalsLength=0,this.color=new THREE.Color,this.material=null,this.uvs=[new THREE.Vector2,new THREE.Vector2,new THREE.Vector2],this.z=0},THREE.RenderableVertex=function(){"use strict";this.position=new THREE.Vector3,this.positionWorld=new THREE.Vector3,this.positionScreen=new THREE.Vector4,this.visible=!0},THREE.RenderableVertex.prototype.copy=function(e){"use strict";this.positionWorld.copy(e.positionWorld),this.positionScreen.copy(e.positionScreen)},THREE.RenderableLine=function(){"use strict";this.id=0,this.v1=new THREE.RenderableVertex,this.v2=new THREE.RenderableVertex,this.vertexColors=[new THREE.Color,new THREE.Color],this.material=null,this.z=0},THREE.RenderableSprite=function(){"use strict";this.id=0,this.object=null,this.x=0,this.y=0,this.z=0,this.rotation=0,this.scale=new THREE.Vector2,this.material=null},THREE.Projector=function(){"use strict";var e,t,i,o,n,r,a,s,c,d,l,u=[],p=0,f=[],v=0,h=[],m=0,g=[],y=0,E=[],_=0,b={objects:[],lights:[],elements:[]},w=(new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3),T=new THREE.Vector4,x=new THREE.Box3(new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,1,1)),C=new THREE.Box3,R=new Array(3),S=(new Array(4),new THREE.Matrix4),L=new THREE.Matrix4,A=(new THREE.Matrix4,new THREE.Matrix3,new THREE.Frustum);new THREE.Vector4,new THREE.Vector4;this.projectVector=function(e,t){console.warn("THREE.Projector: .projectVector() is now vector.project()."),e.project(t)},this.unprojectVector=function(e,t){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),e.unproject(t)},this.pkRay=function(e,t){console.error("THREE.Projector: .pkRay() is now raycaster.setFromCamera().")};var I=new function(){var e=[],t=[],c=null,d=null,u=new THREE.Matrix3,p=function(e){var t=e.position,i=e.positionWorld,o=e.positionScreen;i.copy(t).applyMatrix4(l),o.copy(i).applyMatrix4(L);var n=1/o.w;o.x*=n,o.y*=n,o.z*=n,e.visible=o.x>=-1&&o.x<=1&&o.y>=-1&&o.y<=1&&o.z>=-1&&o.z<=1},E=function(e,t,i){return!0===e.visible||!0===t.visible||!0===i.visible||(R[0]=e.positionScreen,R[1]=t.positionScreen,R[2]=i.positionScreen,x.isIntersectionBox(C.setFromPoints(R)))},_=function(e,t,i){return(i.positionScreen.x-e.positionScreen.x)*(t.positionScreen.y-e.positionScreen.y)-(i.positionScreen.y-e.positionScreen.y)*(t.positionScreen.x-e.positionScreen.x)<0};return{setObject:function(i){d=(c=i).material,u.getNormalMatrix(c.matrixWorld),e.length=0,t.length=0},projectVertex:p,checkTriangleVisibility:E,checkBackfaceCulling:_,pushVertex:function(e,t,n){(i=function(){if(o===v){var e=new THREE.RenderableVertex;return f.push(e),v++,o++,e}return f[o++]}()).position.set(e,t,n),p(i)},pushNormal:function(t,i,o){e.push(t,i,o)},pushUv:function(e,i){t.push(e,i)},pushLine:function(e,t){var i=f[e],o=f[t];(a=function(){if(s===y){var e=new THREE.RenderableLine;return g.push(e),y++,s++,e}return g[s++]}()).id=c.id,a.v1.copy(i),a.v2.copy(o),a.z=(i.positionScreen.z+o.positionScreen.z)/2,a.material=c.material,b.elements.push(a)},pushTriangle:function(i,o,a){var s=f[i],l=f[o],p=f[a];if(!1!==E(s,l,p)&&(d.side===THREE.DoubleSide||!0===_(s,l,p))){(n=function(){if(r===m){var e=new THREE.RenderableFace;return h.push(e),m++,r++,e}return h[r++]}()).id=c.id,n.v1.copy(s),n.v2.copy(l),n.v3.copy(p),n.z=(s.positionScreen.z+l.positionScreen.z+p.positionScreen.z)/3;for(var v=0;v<3;v++){var g=3*arguments[v],y=n.vertexNormalsModel[v];y.set(e[g],e[g+1],e[g+2]),y.applyMatrix3(u).normalize();var w=2*arguments[v];n.uvs[v].set(t[w],t[w+1])}n.vertexNormalsLength=3,n.material=c.material,b.elements.push(n)}}}};function O(){if(d===_){var e=new THREE.RenderableSprite;return E.push(e),_++,d++,e}return E[d++]}function N(e,t){return e.z!==t.z?t.z-e.z:e.id!==t.id?e.id-t.id:0}this.projectScene=function(i,n,a,f){r=0,s=0,d=0,b.elements.length=0,!0===i.autoUpdate&&i.updateMatrixWorld(),void 0===n.parent&&n.updateMatrixWorld(),S.copy(n.matrixWorldInverse.copy(n.matrixWorld).invert()),L.multiplyMatrices(n.projectionMatrix,S),A.setFromMatrix(L),t=0,b.objects.length=0,b.lights.length=0,i.traverseVisible(function(i){if(i instanceof THREE.Light)b.lights.push(i);else if(i instanceof THREE.Mesh||i instanceof THREE.Line||i instanceof THREE.Sprite){if(!1===i.material.visible)return;!1!==i.frustumCulled&&!0!==A.intersectsObject(i)||((e=function(){if(t===p){var e=new THREE.RenderableObject;return u.push(e),p++,t++,e}return u[t++]}()).id=i.id,e.object=i,w.setFromMatrixPosition(i.matrixWorld),w.applyProjection(L),e.z=w.z,b.objects.push(e))}}),!0===a&&b.objects.sort(N);for(var v=0,h=b.objects.length;v<h;v++){var m=b.objects[v].object,g=m.geometry;if(I.setObject(m),l=m.matrixWorld,o=0,m instanceof THREE.Mesh){if(g instanceof THREE.BufferGeometry){var y=g.attributes,E=g.offsets;if(void 0===y.position)continue;for(var _=0,x=(z=y.position.array).length;_<x;_+=3)I.pushVertex(z[_],z[_+1],z[_+2]);if(void 0!==y.normal){var C=y.normal.array;for(_=0,x=C.length;_<x;_+=3)I.pushNormal(C[_],C[_+1],C[_+2])}if(void 0!==y.uv){var R=y.uv.array;for(_=0,x=R.length;_<x;_+=2)I.pushUv(R[_],R[_+1])}if(void 0!==y.index){var P=y.index.array;if(E.length>0)for(v=0;v<E.length;v++){var M=E[v],H=M.index;for(_=M.start,x=M.start+M.count;_<x;_+=3)I.pushTriangle(P[_]+H,P[_+1]+H,P[_+2]+H)}else for(_=0,x=P.length;_<x;_+=3)I.pushTriangle(P[_],P[_+1],P[_+2])}else for(_=0,x=z.length/3;_<x;_+=3)I.pushTriangle(_,_+1,_+2)}}else if(m instanceof THREE.Line){if(g instanceof THREE.BufferGeometry)if(void 0!==(y=g.attributes).position){var z;for(_=0,x=(z=y.position.array).length;_<x;_+=3)I.pushVertex(z[_],z[_+1],z[_+2]);if(void 0!==y.index)for(_=0,x=(P=y.index.array).length;_<x;_+=2)I.pushLine(P[_],P[_+1]);else{var D=m.mode===THREE.LinePieces?2:1;for(_=0,x=z.length/3-1;_<x;_+=D)I.pushLine(_,_+1)}}}else if(m instanceof THREE.Sprite){T.set(l.elements[12],l.elements[13],l.elements[14],1),T.applyMatrix4(L);var j=1/T.w;T.z*=j,T.z>=-1&&T.z<=1&&((c=O()).id=m.id,c.x=T.x*j,c.y=T.y*j,c.z=T.z,c.object=m,c.rotation=m.rotation,c.scale.x=m.scale.x*Math.abs(c.x-(T.x+n.projectionMatrix.elements[0])/(T.w+n.projectionMatrix.elements[12])),c.scale.y=m.scale.y*Math.abs(c.y-(T.y+n.projectionMatrix.elements[5])/(T.w+n.projectionMatrix.elements[13])),c.material=m.material,b.elements.push(c))}}return!0===f&&b.elements.sort(N),b}},THREE.TrackballControls=function(e,t,i){"use strict";var o=this;this.STATE={NONE:-1,ROTATE:0,ZOOM:1,PAN:2,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4},this.object=e,this.domElement=void 0!==t?t:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.noRoll=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.keys=[65,83,68],this.target=new THREE.Vector3;var n=new THREE.Vector3;this._state=this.STATE.NONE;var r=this.STATE.NONE,a=new THREE.Vector3;this._rotateStart=new THREE.Vector3,this._rotateEnd=new THREE.Vector3,this._zoomStart=new THREE.Vector2,this._zoomEnd=new THREE.Vector2;var s=0,c=0;this._panStart=new THREE.Vector2,this._panEnd=new THREE.Vector2,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone();var d={type:"change"},l={type:"start"},u={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else if(this.domElement){var e=this.domElement.getBoundingClientRect(),t=this.domElement.ownerDocument.documentElement;this.screen.left=e.left+window.pageXOffset-t.clientLeft,this.screen.top=e.top+window.pageYOffset-t.clientTop,this.screen.width=e.width,this.screen.height=e.height}},this.handleEvent=function(e){"function"==typeof this[e.type]&&this[e.type](e)};var p,f,v,h,m,g,y,E,_,b=(p=new THREE.Vector2,function(e,t){return p.set((e-o.screen.left)/o.screen.width,(t-o.screen.top)/o.screen.height),p}),w=(f=new THREE.Vector3,v=new THREE.Vector3,h=new THREE.Vector3,function(e,t){h.set((e-.5*o.screen.width-o.screen.left)/(.5*o.screen.width),(.5*o.screen.height+o.screen.top-t)/(.5*o.screen.height),0);var i=h.length();return o.noRoll?i<Math.SQRT1_2?h.z=Math.sqrt(1-i*i):h.z=.5/i:i>1?h.normalize():h.z=Math.sqrt(1-i*i),a.copy(o.object.position).sub(o.target),f.copy(o.object.up).setLength(h.y),f.add(v.copy(o.object.up).cross(a).setLength(h.x)),f.add(a.setLength(h.z)),f});function T(e){!1===o.enabled||Object.keys(window).length<2||(window.removeEventListener("keydown",T),r=o._state,o._state===o.STATE.NONE&&(e.keyCode!==o.keys[o.STATE.ROTATE]||o.noRotate?e.keyCode!==o.keys[o.STATE.ZOOM]||o.noZoom?e.keyCode!==o.keys[o.STATE.PAN]||o.noPan||(o._state=o.STATE.PAN):o._state=o.STATE.ZOOM:o._state=o.STATE.ROTATE))}function x(e){!1===o.enabled||Object.keys(window).length<2||(e.stopPropagation(),o._state!==o.STATE.ROTATE||o.noRotate?o._state!==o.STATE.ZOOM||o.noZoom?o._state!==o.STATE.PAN||o.noPan||o._panEnd.copy(b(e.pageX,e.pageY)):o._zoomEnd.copy(b(e.pageX,e.pageY)):o._rotateEnd.copy(w(e.pageX,e.pageY)))}function C(e){!1===o.enabled||Object.keys(window).length<2||(e.stopPropagation(),o._state=o.STATE.NONE,document.removeEventListener("mousemove",x),document.removeEventListener("mouseup",C),o.dispatchEvent(u))}function R(e){if(!(!1===o.enabled||Object.keys(window).length<2)){e.stopPropagation();var t=0;e.wheelDelta?t=e.wheelDelta/40:e.detail&&(t=-e.detail/3),o._zoomStart.y=.005*t,o.dispatchEvent(l),o.dispatchEvent(u)}}this.rotateCamera=(m=new THREE.Vector3,g=new THREE.Quaternion,function(e,t){var n;void 0===e&&(n=Math.acos(o._rotateStart.dot(o._rotateEnd)/o._rotateStart.length()/o._rotateEnd.length())),(n||void 0!==e)&&(void 0===e?(m.crossVectors(o._rotateStart,o._rotateEnd).normalize(),n*=o.rotateSpeed,g.setFromAxisAngle(m,-n)):g.copy(e),void 0===i||void 0===i.quaternion||void 0!==t&&!0!==t||i.quaternion.multiplyQuaternions(g,i.quaternion),a.applyQuaternion(g),o.object.up.applyQuaternion(g),o._rotateEnd.applyQuaternion(g),o.staticMoving?o._rotateStart.copy(o._rotateEnd):(g.setFromAxisAngle(m,n*(o.dynamicDampingFactor-1)),o._rotateStart.applyQuaternion(g)))}),this.zoomCamera=function(e,t){var n;o._state===o.STATE.TOUCH_ZOOM_PAN?(void 0!==e?n=e:(n=s/c,s=c),a.multiplyScalar(n),void 0===i||void 0===i._zoomFactor||void 0!==t&&!0!==t||(i._zoomFactor*=n,i.fogCls.setFog())):(n=void 0!==e?e:1+(o._zoomEnd.y-o._zoomStart.y)*o.zoomSpeed,void 0===i||void 0===i._zoomFactor||void 0!==t&&!0!==t||(i._zoomFactor*=n,i.fogCls.setFog()),1!==n&&(a.multiplyScalar(n),o.staticMoving?o._zoomStart.copy(o._zoomEnd):o._zoomStart.y+=(o._zoomEnd.y-o._zoomStart.y)*this.dynamicDampingFactor))},this.panCamera=(y=new THREE.Vector2,E=new THREE.Vector3,_=new THREE.Vector3,function(e,t){void 0!==e?(y=e,void 0===i||void 0===i.mouseChange||void 0!==t&&!0!==t||i.mouseChange.add(e)):(y.copy(o._panEnd).sub(o._panStart),void 0===i||void 0===i.mouseChange||void 0!==t&&!0!==t||i.mouseChange.add(o._panEnd).sub(o._panStart)),y.lengthSq()&&(y.multiplyScalar(a.length()*o.panSpeed),_.copy(a).cross(o.object.up).setLength(y.x),_.add(E.copy(o.object.up).setLength(y.y)),o.object.position.add(_),o.target.add(_),o.staticMoving?o._panStart.copy(o._panEnd):o._panStart.add(y.subVectors(o._panEnd,o._panStart).multiplyScalar(o.dynamicDampingFactor)))}),this.checkDistances=function(){o.noZoom&&o.noPan||(a.lengthSq()>o.maxDistance*o.maxDistance&&o.object.position.addVectors(o.target,a.setLength(o.maxDistance)),a.lengthSq()<o.minDistance*o.minDistance&&o.object.position.addVectors(o.target,a.setLength(o.minDistance)))},this.update=function(e){a.subVectors(o.object.position,o.target),o.noRotate||(void 0!==e&&void 0!==e.quaternion?o.rotateCamera(e.quaternion,e.update):o.rotateCamera()),o.noZoom||(void 0!==e&&void 0!==e._zoomFactor?o.zoomCamera(e._zoomFactor,e.update):o.zoomCamera()),o.noPan||(void 0!==e&&void 0!==e.mouseChange?o.panCamera(e.mouseChange,e.update):o.panCamera()),o.object.position.addVectors(o.target,a),o.checkDistances(),o.object.lookAt(o.target),n.distanceToSquared(o.object.position)>1e-6&&(o.dispatchEvent(d),n.copy(o.object.position))},this.reset=function(){o._state=o.STATE.NONE,r=o.STATE.NONE,o.target.copy(o.target0),o.object.position.copy(o.position0),o.object.up.copy(o.up0),a.subVectors(o.object.position,o.target),o.object.lookAt(o.target),o.dispatchEvent(d),n.copy(o.object.position)},Object.keys(window).length>=2&&this.domElement&&(this.domElement.addEventListener("contextmn",function(e){},!1),this.domElement.addEventListener("mousedown",function(e){!1===o.enabled||Object.keys(window).length<2||(e.stopPropagation(),o._state===o.STATE.NONE&&(o._state=e.button),o._state!==o.STATE.ROTATE||o.noRotate?o._state!==o.STATE.ZOOM||o.noZoom?o._state!==o.STATE.PAN||o.noPan||(o._panStart.copy(b(e.pageX,e.pageY)),o._panEnd.copy(o._panStart)):(o._zoomStart.copy(b(e.pageX,e.pageY)),o._zoomEnd.copy(o._zoomStart)):(o._rotateStart.copy(w(e.pageX,e.pageY)),o._rotateEnd.copy(o._rotateStart)),document.addEventListener("mousemove",x,!1),document.addEventListener("mouseup",C,!1),o.dispatchEvent(l))},!1),this.domElement.addEventListener("mousewheel",R,!1),this.domElement.addEventListener("DOMMouseScroll",R,!1),this.domElement.addEventListener("touchstart",function(e){if(!(!1===o.enabled||Object.keys(window).length<2)){switch(e.touches.length){case 1:o._state=o.STATE.TOUCH_ROTATE,o._rotateStart.copy(w(e.touches[0].pageX,e.touches[0].pageY)),o._rotateEnd.copy(o._rotateStart);break;case 2:o._state=o.STATE.TOUCH_ZOOM_PAN;var t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY;c=s=Math.sqrt(t*t+i*i);var n=(e.touches[0].pageX+e.touches[1].pageX)/2,r=(e.touches[0].pageY+e.touches[1].pageY)/2;o._panStart.copy(b(n,r)),o._panEnd.copy(o._panStart);break;default:o._state=o.STATE.NONE}o.dispatchEvent(l)}},!1),this.domElement.addEventListener("touchend",function(e){if(!(!1===o.enabled||Object.keys(window).length<2)){switch(e.touches.length){case 1:o._rotateEnd.copy(w(e.touches[0].pageX,e.touches[0].pageY)),o._rotateStart.copy(o._rotateEnd);break;case 2:s=c=0;var t=(e.touches[0].pageX+e.touches[1].pageX)/2,i=(e.touches[0].pageY+e.touches[1].pageY)/2;o._panEnd.copy(b(t,i)),o._panStart.copy(o._panEnd)}o._state=o.STATE.NONE,o.dispatchEvent(u)}},!1),this.domElement.addEventListener("touchmove",function(e){if(!(!1===o.enabled||Object.keys(window).length<2))switch(e.stopPropagation(),e.touches.length){case 1:o._rotateEnd.copy(w(e.touches[0].pageX,e.touches[0].pageY));break;case 2:var t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY;c=Math.sqrt(t*t+i*i);var n=(e.touches[0].pageX+e.touches[1].pageX)/2,r=(e.touches[0].pageY+e.touches[1].pageY)/2;o._panEnd.copy(b(n,r));break;default:o._state=o.STATE.NONE}},!1),Object.keys(window).length>=2&&window.addEventListener("keydown",T,!1),Object.keys(window).length>=2&&window.addEventListener("keyup",function(e){!1===o.enabled||Object.keys(window).length<2||(o._state=r,window.addEventListener("keydown",T,!1))},!1)),this.handleResize(),this.update()},THREE.TrackballControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.TrackballControls.prototype.constructor=THREE.TrackballControls,THREE.OrthographicTrackballControls=function(e,t,i){this.icn3d;var o=this,n={NONE:-1,ROTATE:0,ZOOM:1,PAN:2,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4};this.object=e,this.domElement=void 0!==t?t:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=.5,this.zoomSpeed=1.2;this.zoomSpeed*=.01,this.panSpeed=.03,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.noRoll=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.keys=[65,83,68],this.target=new THREE.Vector3;var r=new THREE.Vector3;this._state=n.NONE;var a=n.NONE,s=new THREE.Vector3;this._rotateStart=new THREE.Vector3,this._rotateEnd=new THREE.Vector3,this._zoomStart=new THREE.Vector2,this._zoomEnd=new THREE.Vector2;var c=1,d=0,l=0;this._panStart=new THREE.Vector2,this._panEnd=new THREE.Vector2,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone(),this.left0=this.object.left,this.right0=this.object.right,this.top0=this.object.top,this.bottom0=this.object.bottom,this.center0=new THREE.Vector2((this.left0+this.right0)/2,(this.top0+this.bottom0)/2);var u={type:"change"},p={type:"start"},f={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else if(this.domElement){var e=this.domElement.getBoundingClientRect(),t=this.domElement.ownerDocument.documentElement;this.screen.left=e.left+window.pageXOffset-t.clientLeft,this.screen.top=e.top+window.pageYOffset-t.clientTop,this.screen.width=e.width,this.screen.height=e.height}this.left0=this.object.left,this.right0=this.object.right,this.top0=this.object.top,this.bottom0=this.object.bottom,this.center0.set((this.left0+this.right0)/2,(this.top0+this.bottom0)/2)},this.handleEvent=function(e){"function"==typeof this[e.type]&&this[e.type](e)};var v,h,m,g,y,E,_,b,w,T=(v=new THREE.Vector2,function(e,t){return v.set((e-o.screen.left)/o.screen.width,(t-o.screen.top)/o.screen.height),v}),x=(h=new THREE.Vector3,m=new THREE.Vector3,g=new THREE.Vector3,function(e,t){g.set((e-.5*o.screen.width-o.screen.left)/(.5*o.screen.width),(.5*o.screen.height+o.screen.top-t)/(.5*o.screen.height),0);var i=g.length();return o.noRoll?i<Math.SQRT1_2?g.z=Math.sqrt(1-i*i):g.z=.5/i:i>1?g.normalize():g.z=Math.sqrt(1-i*i),s.copy(o.object.position).sub(o.target),h.copy(o.object.up).setLength(g.y),h.add(m.copy(o.object.up).cross(s).setLength(g.x)),h.add(s.setLength(g.z)),h});function C(e){!1===o.enabled||Object.keys(window).length<2||(window.removeEventListener("keydown",C),a=o._state,o._state===n.NONE&&(e.keyCode!==o.keys[n.ROTATE]||o.noRotate?e.keyCode!==o.keys[n.ZOOM]||o.noZoom?e.keyCode!==o.keys[n.PAN]||o.noPan||(o._state=n.PAN):o._state=n.ZOOM:o._state=n.ROTATE))}function R(e){!1===o.enabled||Object.keys(window).length<2||(e.stopPropagation(),o._state!==n.ROTATE||o.noRotate?o._state!==n.ZOOM||o.noZoom?o._state!==n.PAN||o.noPan||o._panEnd.copy(T(e.pageX,e.pageY)):o._zoomEnd.copy(T(e.pageX,e.pageY)):o._rotateEnd.copy(x(e.pageX,e.pageY)))}function S(e){!1===o.enabled||Object.keys(window).length<2||(e.stopPropagation(),o._state=n.NONE,document.removeEventListener("mousemove",R),document.removeEventListener("mouseup",S),o.dispatchEvent(f))}function L(e){if(!(!1===o.enabled||Object.keys(window).length<2)){e.stopPropagation();var t=0;e.wheelDelta?t=e.wheelDelta/40:e.detail&&(t=-e.detail/3),o._zoomStart.y=.01*t,o.dispatchEvent(p),o.dispatchEvent(f)}}this.rotateCamera=(y=new THREE.Vector3,E=new THREE.Quaternion,function(e,t){var n;void 0===e&&(n=Math.acos(o._rotateStart.dot(o._rotateEnd)/o._rotateStart.length()/o._rotateEnd.length())),(n||void 0!==e)&&(void 0===e?(y.crossVectors(o._rotateStart,o._rotateEnd).normalize(),n*=o.rotateSpeed,E.setFromAxisAngle(y,-n)):E.copy(e),void 0===i||void 0===i.quaternion||void 0!==t&&!0!==t||i.quaternion.multiplyQuaternions(E,i.quaternion),s.applyQuaternion(E),o.object.up.applyQuaternion(E),o._rotateEnd.applyQuaternion(E),o.staticMoving?o._rotateStart.copy(o._rotateEnd):(E.setFromAxisAngle(y,n*(o.dynamicDampingFactor-1)),o._rotateStart.applyQuaternion(E)))}),this.zoomCamera=function(e,t){var r;o._state===n.TOUCH_ZOOM_PAN?void 0!==e?r=e:(r=d/l,d=l):r=void 0!==e?e:1+(o._zoomEnd.y-o._zoomStart.y)*o.zoomSpeed/.01,void 0===i||void 0===i._zoomFactor||void 0!==t&&!0!==t||(i._zoomFactor*=r),1!==r&&(c=r,o.object.left=c*o.left0+(1-c)*o.center0.x,o.object.right=c*o.right0+(1-c)*o.center0.x,o.object.top=c*o.top0+(1-c)*o.center0.y,o.object.bottom=c*o.bottom0+(1-c)*o.center0.y,o.staticMoving?o._zoomStart.copy(o._zoomEnd):o._zoomStart.y+=(o._zoomEnd.y-o._zoomStart.y)*this.dynamicDampingFactor)},this.panCamera=(_=new THREE.Vector2,b=new THREE.Vector3,w=new THREE.Vector3,function(e,t){void 0!==e?(_=e,void 0===i||void 0===i.mouseChange||void 0!==t&&!0!==t||i.mouseChange.add(e)):(_.copy(o._panEnd).sub(o._panStart),void 0===i||void 0===i.mouseChange||void 0!==t&&!0!==t||i.mouseChange.add(o._panEnd).sub(o._panStart)),_.lengthSq()&&(_.multiplyScalar(s.length()*o.panSpeed),w.copy(s).cross(o.object.up).setLength(_.x),w.add(b.copy(o.object.up).setLength(_.y)),o.object.position.add(w),o.target.add(w),o.staticMoving?o._panStart.copy(o._panEnd):o._panStart.add(_.subVectors(o._panEnd,o._panStart).multiplyScalar(o.dynamicDampingFactor)))}),this.update=function(e){s.subVectors(o.object.position,o.target),o.noRotate||(void 0!==e&&void 0!==e.quaternion?o.rotateCamera(e.quaternion,e.update):o.rotateCamera()),o.noZoom||(void 0!==e&&void 0!==e._zoomFactor?o.zoomCamera(e._zoomFactor,e.update):o.zoomCamera(),o.object.updateProjectionMatrix()),o.noPan||(void 0!==e&&void 0!==e.mouseChange?o.panCamera(e.mouseChange,e.update):o.panCamera()),o.object.position.addVectors(o.target,s),o.object.lookAt(o.target),r.distanceToSquared(o.object.position)>1e-6&&(o.dispatchEvent(u),r.copy(o.object.position))},this.reset=function(){o._state=n.NONE,a=n.NONE,o.target.copy(o.target0),o.object.position.copy(o.position0),o.object.up.copy(o.up0),s.subVectors(o.object.position,o.target),o.object.left=o.left0,o.object.right=o.right0,o.object.top=o.top0,o.object.bottom=o.bottom0,o.object.lookAt(o.target),o.dispatchEvent(u),r.copy(o.object.position)},Object.keys(window).length>=2&&this.domElement&&(this.domElement.addEventListener("contextmn",function(e){},!1),this.domElement.addEventListener("mousedown",function(e){!1===o.enabled||Object.keys(window).length<2||(e.stopPropagation(),o._state===n.NONE&&(o._state=e.button),o._state!==n.ROTATE||o.noRotate?o._state!==n.ZOOM||o.noZoom?o._state!==n.PAN||o.noPan||(o._panStart.copy(T(e.pageX,e.pageY)),o._panEnd.copy(o._panStart)):(o._zoomStart.copy(T(e.pageX,e.pageY)),o._zoomEnd.copy(o._zoomStart)):(o._rotateStart.copy(x(e.pageX,e.pageY)),o._rotateEnd.copy(o._rotateStart)),document.addEventListener("mousemove",R,!1),document.addEventListener("mouseup",S,!1),o.dispatchEvent(p))},!1),this.domElement.addEventListener("mousewheel",L,!1),this.domElement.addEventListener("DOMMouseScroll",L,!1),this.domElement.addEventListener("touchstart",function(e){if(!(!1===o.enabled||Object.keys(window).length<2)){switch(e.touches.length){case 1:o._state=n.TOUCH_ROTATE,o._rotateStart.copy(x(e.touches[0].pageX,e.touches[0].pageY)),o._rotateEnd.copy(o._rotateStart);break;case 2:o._state=n.TOUCH_ZOOM_PAN;var t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY;l=d=Math.sqrt(t*t+i*i);var r=(e.touches[0].pageX+e.touches[1].pageX)/2,a=(e.touches[0].pageY+e.touches[1].pageY)/2;o._panStart.copy(T(r,a)),o._panEnd.copy(o._panStart);break;default:o._state=n.NONE}o.dispatchEvent(p)}},!1),this.domElement.addEventListener("touchend",function(e){if(!(!1===o.enabled||Object.keys(window).length<2)){switch(e.touches.length){case 1:o._rotateEnd.copy(x(e.touches[0].pageX,e.touches[0].pageY)),o._rotateStart.copy(o._rotateEnd);break;case 2:d=l=0;var t=(e.touches[0].pageX+e.touches[1].pageX)/2,i=(e.touches[0].pageY+e.touches[1].pageY)/2;o._panEnd.copy(T(t,i)),o._panStart.copy(o._panEnd)}o._state=n.NONE,o.dispatchEvent(f)}},!1),this.domElement.addEventListener("touchmove",function(e){if(!(!1===o.enabled||Object.keys(window).length<2))switch(e.stopPropagation(),e.touches.length){case 1:o._rotateEnd.copy(x(e.touches[0].pageX,e.touches[0].pageY));break;case 2:var t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY;l=Math.sqrt(t*t+i*i);var r=(e.touches[0].pageX+e.touches[1].pageX)/2,a=(e.touches[0].pageY+e.touches[1].pageY)/2;o._panEnd.copy(T(r,a));break;default:o._state=n.NONE}},!1),window.addEventListener("keydown",C,!1),window.addEventListener("keyup",function(e){!1===o.enabled||Object.keys(window).length<2||(o._state=a,window.addEventListener("keydown",C,!1))},!1)),this.handleResize(),this.update()},THREE.OrthographicTrackballControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.OrthographicTrackballControls.prototype.constructor=THREE.OrthographicTrackballControls;var MMTF={};function initIcn3dpyMMTF(e){function t(e,t,i){for(var o=(e.byteLength,0),n=i.length;n>o;o++){var r=i.charCodeAt(o);if(128>r)e.setUint8(t++,r>>>0&127|0);else if(2048>r)e.setUint8(t++,r>>>6&31|192),e.setUint8(t++,r>>>0&63|128);else if(65536>r)e.setUint8(t++,r>>>12&15|224),e.setUint8(t++,r>>>6&63|128),e.setUint8(t++,r>>>0&63|128);else{if(!(1114112>r))throw new Error("bad codepoint "+r);e.setUint8(t++,r>>>18&7|240),e.setUint8(t++,r>>>12&63|128),e.setUint8(t++,r>>>6&63|128),e.setUint8(t++,r>>>0&63|128)}}}function i(e){for(var t=0,i=0,o=e.length;o>i;i++){var n=e.charCodeAt(i);if(128>n)t+=1;else if(2048>n)t+=2;else if(65536>n)t+=3;else{if(!(1114112>n))throw new Error("bad codepoint "+n);t+=4}}return t}function o(e){var o=new ArrayBuffer(function e(t){var o=typeof t;if("string"===o){if(32>(n=i(t)))return 1+n;if(256>n)return 2+n;if(65536>n)return 3+n;if(4294967296>n)return 5+n}if(t instanceof Uint8Array){if(256>(n=t.byteLength))return 2+n;if(65536>n)return 3+n;if(4294967296>n)return 5+n}if("number"===o){if(Math.floor(t)!==t)return 9;if(t>=0){if(128>t)return 1;if(256>t)return 2;if(65536>t)return 3;if(4294967296>t)return 5;throw new Error("Number too big 0x"+t.toString(16))}if(t>=-32)return 1;if(t>=-128)return 2;if(t>=-32768)return 3;if(t>=-2147483648)return 5;throw new Error("Number too small -0x"+t.toString(16).substr(1))}if("boolean"===o||null===t)return 1;if("object"===o){var n,r=0;if(Array.isArray(t)){n=t.length;for(var a=0;n>a;a++)r+=e(t[a])}else{var s=Object.keys(t);for(n=s.length,a=0;n>a;a++){var c=s[a];r+=e(c)+e(t[c])}}if(16>n)return 1+r;if(65536>n)return 3+r;if(4294967296>n)return 5+r;throw new Error("Array or object too long 0x"+n.toString(16))}throw new Error("Unknown type "+o)}(e));return function e(o,n,r){var a=typeof o;if("string"===a){if(32>(s=i(o)))return n.setUint8(r,160|s),t(n,r+1,o),1+s;if(256>s)return n.setUint8(r,217),n.setUint8(r+1,s),t(n,r+2,o),2+s;if(65536>s)return n.setUint8(r,218),n.setUint16(r+1,s),t(n,r+3,o),3+s;if(4294967296>s)return n.setUint8(r,219),n.setUint32(r+1,s),t(n,r+5,o),5+s}if(o instanceof Uint8Array){var s=o.byteLength,c=new Uint8Array(n.buffer);if(256>s)return n.setUint8(r,196),n.setUint8(r+1,s),c.set(o,r+2),2+s;if(65536>s)return n.setUint8(r,197),n.setUint16(r+1,s),c.set(o,r+3),3+s;if(4294967296>s)return n.setUint8(r,198),n.setUint32(r+1,s),c.set(o,r+5),5+s}if("number"===a){if(!isFinite(o))throw new Error("Number not finite: "+o);if(Math.floor(o)!==o)return n.setUint8(r,203),n.setFloat64(r+1,o),9;if(o>=0){if(128>o)return n.setUint8(r,o),1;if(256>o)return n.setUint8(r,204),n.setUint8(r+1,o),2;if(65536>o)return n.setUint8(r,205),n.setUint16(r+1,o),3;if(4294967296>o)return n.setUint8(r,206),n.setUint32(r+1,o),5;throw new Error("Number too big 0x"+o.toString(16))}if(o>=-32)return n.setInt8(r,o),1;if(o>=-128)return n.setUint8(r,208),n.setInt8(r+1,o),2;if(o>=-32768)return n.setUint8(r,209),n.setInt16(r+1,o),3;if(o>=-2147483648)return n.setUint8(r,210),n.setInt32(r+1,o),5;throw new Error("Number too small -0x"+(-o).toString(16).substr(1))}if(null===o)return n.setUint8(r,192),1;if("boolean"===a)return n.setUint8(r,o?195:194),1;if("object"===a){var d=0,l=Array.isArray(o);if(l)s=o.length;else{var u=Object.keys(o);s=u.length}if(16>s?(n.setUint8(r,s|(l?144:128)),d=1):65536>s?(n.setUint8(r,l?220:222),n.setUint16(r+1,s),d=3):4294967296>s&&(n.setUint8(r,l?221:223),n.setUint32(r+1,s),d=5),l)for(var p=0;s>p;p++)d+=e(o[p],n,r+d);else for(p=0;s>p;p++){var f=u[p];d+=e(f,n,r+d),d+=e(o[f],n,r+d)}return d}throw new Error("Unknown type "+a)}(e,new DataView(o),0),new Uint8Array(o)}function n(e,t,i){return t?new e(t.buffer,t.byteOffset,t.byteLength/(i||1)):void 0}function r(e){return n(DataView,e)}function a(e){return n(Uint8Array,e)}function s(e){return n(Int8Array,e)}function c(e){return n(Int32Array,e,4)}function d(e,t){var i=e.length/2;t||(t=new Int16Array(i));for(var o=0,n=0;i>o;++o,n+=2)t[o]=e[n]<<8^e[n+1]<<0;return t}function l(e,t){var i=e.length/4;t||(t=new Int32Array(i));for(var o=0,n=0;i>o;++o,n+=4)t[o]=e[n]<<24^e[n+1]<<16^e[n+2]<<8^e[n+3]<<0;return t}function u(e,t){var i=e.length;t||(t=new Uint8Array(4*i));for(var o=r(t),n=0;i>n;++n)o.setInt32(4*n,e[n]);return a(t)}function p(e,t,i){var o=e.length,n=1/t;i||(i=new Float32Array(o));for(var r=0;o>r;++r)i[r]=e[r]*n;return i}function f(e,t,i){var o=e.length;i||(i=new Int32Array(o));for(var n=0;o>n;++n)i[n]=Math.round(e[n]*t);return i}function v(e,t){var i,o;if(!t){var n=0;for(i=0,o=e.length;o>i;i+=2)n+=e[i+1];t=new e.constructor(n)}var r=0;for(i=0,o=e.length;o>i;i+=2)for(var a=e[i],s=e[i+1],c=0;s>c;++c)t[r]=a,++r;return t}function h(e){if(0===e.length)return new Int32Array;var t,i,o=2;for(t=1,i=e.length;i>t;++t)e[t-1]!==e[t]&&(o+=2);var n=new Int32Array(o),r=0,a=1;for(t=1,i=e.length;i>t;++t)e[t-1]!==e[t]?(n[r]=e[t-1],n[r+1]=a,a=1,r+=2):++a;return n[r]=e[e.length-1],n[r+1]=a,n}function m(e,t){var i=e.length;t||(t=new e.constructor(i)),i&&(t[0]=e[0]);for(var o=1;i>o;++o)t[o]=e[o]+t[o-1];return t}function g(e,t){var i=e.length;t||(t=new e.constructor(i)),t[0]=e[0];for(var o=1;i>o;++o)t[o]=e[o]-e[o-1];return t}function y(e,t){var i,o,n=e instanceof Int8Array?127:32767,r=-n-1,a=e.length;if(!t){var s=0;for(i=0;a>i;++i)e[i]<n&&e[i]>r&&++s;t=new Int32Array(s)}for(i=0,o=0;a>i;){for(var c=0;e[i]===n||e[i]===r;)c+=e[i],++i;c+=e[i],++i,t[o]=c,++o}return t}function E(e,t,i){return p(y(e,c(i)),t,i)}function _(e,t,i){var o,r,a,s=y(e,c(i));return o=s,r=t,a=n(Float32Array,s,4),p(m(o,c(a)),r,a)}function b(e,t,i){return function(e,t){var i,o=t?127:32767,n=-o-1,r=e.length,a=0;for(i=0;r>i;++i)0===(d=e[i])?++a:d>0?(a+=Math.ceil(d/o),d%o==0&&(a+=1)):(a+=Math.ceil(d/n),d%n==0&&(a+=1));var s=t?new Int8Array(a):new Int16Array(a),c=0;for(i=0;r>i;++i){var d;if((d=e[i])>=0)for(;d>=o;)s[c]=o,++c,d-=o;else for(;n>=d;)s[c]=n,++c,d-=n;s[c]=d,++c}return s}(g(f(e,t),o),i);var o}function w(e,t,i,o){var n=new ArrayBuffer(12+o.byteLength),r=new Uint8Array(n),a=new DataView(n);return a.setInt32(0,e),a.setInt32(4,t),i&&r.set(i,8),r.set(o,12),r}function T(e){return w(2,e.length,void 0,a(e))}function x(e){return w(4,e.length,void 0,u(e))}function C(e,t){return w(5,e.length/t,u([t]),a(e))}function R(e){return w(6,e.length,void 0,u(h(e)))}function S(e){return w(8,e.length,void 0,u(h(g(e))))}function L(e,t){return w(9,e.length,u([t]),u(h(f(e,t))))}function A(e,t){return w(10,e.length,u([t]),function(e,t){var i=e.length;t||(t=new Uint8Array(2*i));for(var o=r(t),n=0;i>n;++n)o.setInt16(2*n,e[n]);return a(t)}(b(e,t)))}function I(e){var t={};return D.forEach(function(i){void 0!==e[i]&&(t[i]=e[i])}),e.bondAtomList&&(t.bondAtomList=x(e.bondAtomList)),e.bondOrderList&&(t.bondOrderList=T(e.bondOrderList)),t.xCoordList=A(e.xCoordList,1e3),t.yCoordList=A(e.yCoordList,1e3),t.zCoordList=A(e.zCoordList,1e3),e.bFactorList&&(t.bFactorList=A(e.bFactorList,100)),e.atomIdList&&(t.atomIdList=S(e.atomIdList)),e.altLocList&&(t.altLocList=R(e.altLocList)),e.occupancyList&&(t.occupancyList=L(e.occupancyList,100)),t.groupIdList=S(e.groupIdList),t.groupTypeList=x(e.groupTypeList),e.secStructList&&(t.secStructList=T(e.secStructList)),e.insCodeList&&(t.insCodeList=R(e.insCodeList)),e.sequenceIndexList&&(t.sequenceIndexList=S(e.sequenceIndexList)),t.chainIdList=C(e.chainIdList,4),e.chainNameList&&(t.chainNameList=C(e.chainNameList,4)),t}function O(e){function t(e){for(var t={},i=0;e>i;i++){t[r()]=r()}return t}function i(t){var i=e.subarray(a,a+t);return a+=t,i}function o(t){var i=e.subarray(a,a+t);a+=t;if(t>65535){for(var o=[],n=0;n<i.length;n+=65535)o.push(String.fromCharCode.apply(null,i.subarray(n,n+65535)));return o.join("")}return String.fromCharCode.apply(null,i)}function n(e){for(var t=new Array(e),i=0;e>i;i++)t[i]=r();return t}function r(){var r,c,d=e[a];if(0==(128&d))return a++,d;if(128==(240&d))return a++,t(c=15&d);if(144==(240&d))return a++,n(c=15&d);if(160==(224&d))return a++,o(c=31&d);if(224==(224&d))return r=s.getInt8(a),a++,r;switch(d){case 192:return a++,null;case 194:return a++,!1;case 195:return a++,!0;case 196:return c=s.getUint8(a+1),a+=2,i(c);case 197:return c=s.getUint16(a+1),a+=3,i(c);case 198:return c=s.getUint32(a+1),a+=5,i(c);case 202:return r=s.getFloat32(a+1),a+=5,r;case 203:return r=s.getFloat64(a+1),a+=9,r;case 204:return r=e[a+1],a+=2,r;case 205:return r=s.getUint16(a+1),a+=3,r;case 206:return r=s.getUint32(a+1),a+=5,r;case 208:return r=s.getInt8(a+1),a+=2,r;case 209:return r=s.getInt16(a+1),a+=3,r;case 210:return r=s.getInt32(a+1),a+=5,r;case 217:return c=s.getUint8(a+1),a+=2,o(c);case 218:return c=s.getUint16(a+1),a+=3,o(c);case 219:return c=s.getUint32(a+1),a+=5,o(c);case 220:return c=s.getUint16(a+1),a+=3,n(c);case 221:return c=s.getUint32(a+1),a+=5,n(c);case 222:return c=s.getUint16(a+1),a+=3,t(c);case 223:return c=s.getUint32(a+1),a+=5,t(c)}throw new Error("Unknown type 0x"+d.toString(16))}var a=0,s=new DataView(e.buffer);return r()}function N(e,t,i,o){switch(e){case 1:return function(e,t){var i=e.length;t||(t=new Float32Array(i/4));for(var o=r(t),n=r(e),a=0,s=0,c=i/4;c>a;++a,s+=4)o.setFloat32(s,n.getFloat32(s),!0);return t}(t);case 2:return s(t);case 3:return d(t);case 4:return l(t);case 5:return a(t);case 6:return v(l(t),new Uint8Array(i));case 7:return v(l(t));case 8:return m(v(l(t)),h);case 9:return n=l(t),u=l(o)[0],p(v(n,c(f)),u,f);case 10:return _(d(t),l(o)[0]);case 11:return p(d(t),l(o)[0]);case 12:return E(d(t),l(o)[0]);case 13:return E(s(t),l(o)[0]);case 14:return y(d(t));case 15:return y(s(t))}var n,u,f,h}function P(e,t){var i=(t=t||{}).ignoreFields,o={};return j.forEach(function(t){var n,a,s,c,d,l=!!i&&-1!==i.indexOf(t),u=e[t];l||void 0===u||(u instanceof Uint8Array?o[t]=N.apply(null,(a=r(n=u),s=a.getInt32(0),c=a.getInt32(4),d=n.subarray(8,12),[s,n=n.subarray(12),c,d])):o[t]=u)}),o}function M(e){return String.fromCharCode.apply(null,e).replace(/\0/g,"")}function H(e,t){return e instanceof ArrayBuffer&&(e=new Uint8Array(e)),P(e instanceof Uint8Array?O(e):e,t)}function z(e,t,i,o){var n=new XMLHttpRequest;n.addEventListener("load",function(){try{var e=H(n.response);i(e)}catch(e){o(e)}},!0),n.addEventListener("error",o,!0),n.responseType="arraybuffer",n.open("GET",t+e.toUpperCase()),n.send()}var D=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],j=D.concat(["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"]),F="//mmtf.rcsb.org/v1.0/",V=F+"full/",U=F+"reduced/";return e.encode=function(e){return o(I(e))},e.decode=H,e.traverse=function(e,t,i){var o,n,r,a,s,c,d=(i=i||{}).firstModelOnly,l=t.onModel,u=t.onChain,p=t.onGroup,f=t.onAtom,v=t.onBond,h=0,m=0,g=0,y=0,E=0,_=-1,b=e.chainNameList,w=e.secStructList,T=e.insCodeList,x=e.sequenceIndexList,C=e.atomIdList,R=e.bFactorList,S=e.altLocList,L=e.occupancyList,A=e.bondAtomList,I=e.bondOrderList;for(o=0,n=e.chainsPerModel.length;n>o&&!(d&&h>0);++o){var O=e.chainsPerModel[h];for(l&&l({chainCount:O,modelIndex:h}),r=0;O>r;++r){var N=e.groupsPerChain[m];if(u){var P=M(e.chainIdList.subarray(4*m,4*m+4)),H=null;b&&(H=M(b.subarray(4*m,4*m+4))),u({groupCount:N,chainIndex:m,modelIndex:h,chainId:P,chainName:H})}for(a=0;N>a;++a){var z=e.groupList[e.groupTypeList[g]],D=z.atomNameList.length;if(p){var j=null;w&&(j=w[g]);var F=null;e.insCodeList&&(F=String.fromCharCode(T[g]));var V=null;x&&(V=x[g]),p({atomCount:D,groupIndex:g,chainIndex:m,modelIndex:h,groupId:e.groupIdList[g],groupType:e.groupTypeList[g],groupName:z.groupName,singleLetterCode:z.singleLetterCode,chemCompType:z.chemCompType,secStruct:j,insCode:F,sequenceIndex:V})}for(s=0;D>s;++s){if(f){var U=null;C&&(U=C[y]);var k=null;R&&(k=R[y]);var G=null;S&&(G=String.fromCharCode(S[y]));var B=null;L&&(B=L[y]),f({atomIndex:y,groupIndex:g,chainIndex:m,modelIndex:h,atomId:U,element:z.elementList[s],atomName:z.atomNameList[s],formalCharge:z.formalChargeList[s],xCoord:e.xCoordList[y],yCoord:e.yCoordList[y],zCoord:e.zCoordList[y],bFactor:k,altLoc:G,occupancy:B})}y+=1}if(v){var X=z.bondAtomList;for(s=0,c=z.bondOrderList.length;c>s;++s)v({atomIndex1:y-D+X[2*s],atomIndex2:y-D+X[2*s+1],bondOrder:z.bondOrderList[s]})}g+=1}m+=1}if(E=_+1,_=y-1,v&&A)for(s=0,c=A.length;c>s;s+=2){var q=A[s],W=A[s+1];(q>=E&&_>=q||W>=E&&_>=W)&&v({atomIndex1:q,atomIndex2:W,bondOrder:I?I[s/2]:null})}h+=1}},e.fetch=function(e,t,i){z(e,V,t,i)},e.fetchReduced=function(e,t,i){z(e,U,t,i)},e.version="v1.0.1",e.fetchUrl=V,e.fetchReducedUrl=U,e.encodeMsgpack=o,e.encodeMmtf=I,e.decodeMsgpack=O,e.decodeMmtf=P,e}MMTF=initIcn3dpyMMTF(MMTF),function(e,t,i){var o,n="__instance__",r="firstChild",a=setTimeout;function s(e){return void 0!==e}function c(e){return"object"==typeof e}function d(e){return Object.keys(e).length}function l(e,t,i){return e<t?t:e>i?i:e}function u(e,t){return parseInt(e,t||10)}function p(e){return Math.round(e)}function f(e){var t,i,o,n,r,a,s,c,d=+e[0],l=+e[1],u=+e[2];switch(a=u*(1-l),s=u*(1-(r=6*d-(n=Math.floor(6*d)))*l),c=u*(1-(1-r)*l),n=n||0,s=s||0,c=c||0,n%6){case 0:t=u,i=c,o=a;break;case 1:t=s,i=u,o=a;break;case 2:t=a,i=u,o=c;break;case 3:t=a,i=s,o=u;break;case 4:t=c,i=a,o=u;break;case 5:t=u,i=a,o=s}return[p(255*t),p(255*i),p(255*o)]}function v(e){return m(f(e))}function h(e){var t,i=+e[0],o=+e[1],n=+e[2],r=Math.max(i,o,n),a=Math.min(i,o,n),s=r-a,c=0===r?0:s/r,d=r/255;switch(r){case a:t=0;break;case i:t=o-n+s*(o<n?6:0),t/=6*s;break;case o:t=n-i+2*s,t/=6*s;break;case n:t=i-o+4*s,t/=6*s}return[t,c,d]}function m(e){var t=+e[2]|+e[1]<<8|+e[0]<<16;return(t="000000"+t.toString(16)).slice(-6)}function g(e){return h(y(e))}function y(e){return 3===e.length&&(e=e.replace(/./g,"$&$&")),[u(e[0]+e[1],16),u(e[2]+e[3],16),u(e[4]+e[5],16)]}function E(e){return[+e[0]/360,+e[1]/100,+e[2]/100]}function _(e){return[p(360*+e[0]),p(100*+e[1]),p(100*+e[2])]}function b(e){if(c(e))return e;var t=/\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i.exec(e),i=/\s*hsv\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)\s*$/i.exec(e);return"#"===e[0]&&e.match(/^#([\da-f]{3}|[\da-f]{6})$/i)?g(e.slice(1)):i?E([+i[1],+i[2],+i[3]]):t?h([+t[1],+t[2],+t[3]]):[0,1,1]}(o=e.CP=function(i,o,u){var p=t.body,h=t.documentElement,m=this,g=e.CP,y=!1,E={},_=t.createElement("div"),b="touchstart mousedown",w="touchmove mousemove",T="touchend mouseup",x="orientationchange resize";if(!(m instanceof g))return new g(i,o);function C(e,t,i){for(var o=0,n=(e=e.split(/\s+/)).length;o<n;++o)t.addEventListener(e[o],i,!1)}function R(e,t,i){for(var o=0,n=(e=e.split(/\s+/)).length;o<n;++o)t.removeEventListener(e[o],i)}function S(e,t){var i="touches",o="clientX",n="clientY",r=t[i]?t[i][0][o]:t[o],a=t[i]?t[i][0][n]:t[n],s=L(e);return{x:r-s.l,y:a-s.t}}function L(t){var i,o,n;return t===e?(i=e.pageXOffset||h.scrollLeft,o=e.pageYOffset||h.scrollTop):(i=(n=t.getBoundingClientRect()).left,o=n.top),{l:i,t:o}}function A(e,t){for(;(e=e.parentElement)&&e!==t;);return e}function I(e){e&&e.preventDefault()}function O(t){return t===e?{w:e.innerWidth,h:e.innerHeight}:{w:t.offsetWidth,h:t.offsetHeight}}function N(e){return y||!!s(e)&&e}function P(e){y=e}function M(e,t,i){if(!s(E[e]))return m;if(s(i))s(E[e][i])&&E[e][i].apply(m,t);else for(var o in E[e])E[e][o].apply(m,t);return m}g[n][i.id||i.name||d(g[n])]=m,s(o)&&!0!==o||(o=b),P(g.parse(i.getAttribute("data-color")||i.value||[0,1,1])),_.className="color-picker",_.innerHTML='<div class="color-picker-control"><span class="color-picker-h"><i></i></span><span class="color-picker-sv"><i></i></span></div>';var H,z=_[r].children,D=N([0,1,1]),j=z[0],F=z[1],V=j[r],U=F[r],k=0,G=0,B=0,X=0,q=0,W=0,Y=0,Z=0,Q=v(D);function K(e,t){e&&"h"!==e||M("change:h",t),e&&"sv"!==e||M("change:sv",t),M("change",t)}function $(){return _.parentNode}function J(n,r){n||((u||r||p).appendChild(_),m.visible=!0),Y=O(_).w,Z=O(_).h;var a=O(F),s=O(U),c=O(j).h,d=a.w,h=a.h,g=O(V).h,y=s.w,E=s.h;if(n){function L(e){var t=e.target,o=t===i||A(t,i)===i;o?J():m.exit(),M(o?"enter":"exit",[m])}_.style.left=_.style.top="-9999px",!1!==o&&C(o,i,L),m.create=function(){return J(1),M("create",[m]),m},m.destroy=function(){return!1!==o&&R(o,i,L),m.exit(),P(!1),M("destroy",[m]),m}}else ee();function z(e){f(D);var t=f([D[0],1,1]);F.style.backgroundColor="rgb("+t.join(",")+")",P(D),I(e)}function q(e){var t,i,o,n,r,a;B&&(i=l(S(j,t=e).y,0,c),D[0]=(c-i)/c,V.style.top=i-g/2+"px",z(t),Q=v(D),k||(M("drag:h",[Q,m]),M("drag",[Q,m]),K("h",[Q,m]))),X&&(n=S(F,o=e),r=l(n.x,0,d),a=l(n.y,0,h),D[1]=1-(d-r)/d,D[2]=(h-a)/h,U.style.right=d-r-y/2+"px",U.style.top=a-E/2+"px",z(o),Q=v(D),G||(M("drag:sv",[Q,m]),M("drag",[Q,m]),K("sv",[Q,m]))),k=0,G=0}function W(e){var t=e.target,n=B?"h":"sv",r=[v(D),m],a=t===i||A(t,i)===i,s=t===_||A(t,_)===_;a||s?s&&(M("stop:"+n,r),M("stop",r),K(n,r)):$()&&!1!==o&&(m.exit(),M("exit",[m]),K(0,r)),B=0,X=0}function te(e){k=1,B=1,q(e),I(e),M("start:h",[Q,m]),M("start",[Q,m]),K("h",[Q,m])}function ie(e){G=1,X=1,q(e),I(e),M("start:sv",[Q,m]),M("start",[Q,m]),K("sv",[Q,m])}H=function(){D=N(D),z(),V.style.top=c-g/2-c*+D[0]+"px",U.style.right=d-y/2-d*+D[1]+"px",U.style.top=h-E/2-h*+D[2]+"px"},m.exit=function(i){return $()&&($().removeChild(_),m.visible=!1),R(b,j,te),R(b,F,ie),R(w,t,q),R(T,t,W),R(x,e,ee),m},H(),n||(C(b,j,te),C(b,F,ie),C(w,t,q),C(T,t,W),C(x,e,ee))}function ee(){return m.fit()}return J(1),a(function(){var e=[v(D),m];M("create",e),K(0,e)},0),m.fit=function(t){var o=O(e),n=O(h),r=o.w-n.w,a=o.h-h.clientHeight,d=L(e),u=L(i);if(q=u.l+d.l,W=u.t+d.t+O(i).h,c(t))s(t[0])&&(q=t[0]),s(t[1])&&(W=t[1]);else{var p=d.l,f=d.t,v=d.l+o.w-Y-r,g=d.t+o.h-Z-a;q=l(q,p,v)>>0,W=l(W,f,g)>>0}return _.style.left=q+"px",_.style.top=W+"px",M("fit",[m]),m},m.set=function(e){return s(e)?("string"==typeof e&&(e=g.parse(e)),P(e),H(),m):N()},m.get=function(e){return N(e)},m.target=i,m.picker=_,m.visible=!1,m.on=function(e,t,i){return s(e)?s(t)?(s(E[e])||(E[e]={}),s(i)||(i=d(E[e])),E[e][i]=t,m):E[e]:E},m.off=function(e,t){return s(e)?s(t)?(delete E[e][t],m):(E[e]={},m):(E={},m)},m.fire=M,m.hooks=E,m.enter=function(e){return J(0,e)},m}).version="1.3.9",o[n]={},o.each=function(e,t){return a(function(){var t,i=o[n];for(t in i)e(i[t],t,i)},0===t?0:t||1),o},o.parse=b,o._HSV2RGB=f,o._HSV2HEX=v,o._RGB2HSV=h,o._HEX2HSV=g,o._HEX2RGB=function(e){return[+(t=y(e))[0]/255,+t[1]/255,+t[2]/255];var t},o.HSV2RGB=function(e){return f(E(e))},o.HSV2HEX=function(e){return v(E(e))},o.RGB2HSV=function(e){return _(h(e))},o.RGB2HEX=m,o.HEX2HSV=function(e){return _(g(e))},o.HEX2RGB=y}(window,document);var saveAs=function(e){"use strict";if(!(void 0===e||"undefined"!=typeof navigator&&/MSIE [1-9]\./.test(navigator.userAgent))){var t=function(){return e.URL||e.webkitURL||e},i=e.document.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in i,n=/constructor/i.test(e.HTMLElement)||e.safari,r=/CriOS\/[\d]+/.test(navigator.userAgent),a=e.setImmediate||e.setTimeout,s=function(e){a(function(){throw e},0)},c=function(e){setTimeout(function(){"string"==typeof e?t().revokeObjectURL(e):e.remove()},4e4)},d=function(e){return/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob([String.fromCharCode(65279),e],{type:e.type}):e},l=function(l,u,p){p||(l=d(l));var f,v=this,h="application/octet-stream"===(l?l.type:void 0),m=function(){!function(e,t,i){for(var o=(t=[].concat(t)).length;o--;){var n=e["on"+t[o]];if("function"==typeof n)try{n.call(e,i||e)}catch(e){s(e)}}}(v,"writestart progress write writeend".split(" "))};if(v.readyState=v.INIT,o)return f||(f=t().createObjectURL(l)),void a(function(){var e,t;i.href=f,i.download=u,e=i,t=new MouseEvent("click"),e.dispatchEvent(t),m(),c(f),v.readyState=v.DONE},0);!function(){if((r||h&&n)&&e.FileReader){var i=new FileReader;return i.onloadend=function(){var t=r?i.result:i.result.replace(/^data:[^;]*;/,"data:attachment/file;");e.open(t,"_blank")||(e.location.href=t),t=void 0,v.readyState=v.DONE,m()},i.readAsDataURL(l),void(v.readyState=v.INIT)}f||(f=t().createObjectURL(l)),h?e.location.href=f:e.open(f,"_blank")||(e.location.href=f);v.readyState=v.DONE,m(),c(f)}()},u=l.prototype;return"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob?function(e,t,i){return t=t||e.name||"download",i||(e=d(e)),navigator.msSaveOrOpenBlob(e,t)}:(u.abort=function(){},u.readyState=u.INIT=0,u.WRITING=1,u.DONE=2,u.error=u.onwritestart=u.onprogress=u.onwrite=u.onabort=u.onerror=u.onwriteend=null,function(e,t,i){return new l(e,t||e.name||"download",i)})}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this);!function(e){"use strict";var t=e.HTMLCanvasElement&&e.HTMLCanvasElement.prototype,i=e.Blob&&function(){try{return Boolean(new Blob)}catch(e){return!1}}(),o=i&&e.Uint8Array&&function(){try{return 100===new Blob([new Uint8Array(100)]).size}catch(e){return!1}}(),n=e.BlobBuilder||e.WebKitBlobBuilder||e.MozBlobBuilder||e.MSBlobBuilder,r=/^data:((.*?)(;charset=.*?)?)(;base64)?,/,a=(i||n)&&e.atob&&e.ArrayBuffer&&e.Uint8Array&&function(e){var t,a,s,c,d,l,u,p,f;if(!(t=e.match(r)))throw new Error("invalid data URI");for(a=t[2]?t[1]:"text/plain"+(t[3]||";charset=US-ASCII"),s=!!t[4],c=e.slice(t[0].length),d=s?atob(c):decodeURIComponent(c),l=new ArrayBuffer(d.length),u=new Uint8Array(l),p=0;p<d.length;p+=1)u[p]=d.charCodeAt(p);return i?new Blob([o?u:l],{type:a}):((f=new n).append(l),f.getBlob(a))};e.HTMLCanvasElement&&!t.toBlob&&(t.mozGetAsFile?t.toBlob=function(e,i,o){var n=this;setTimeout(function(){o&&t.toDataURL&&a?e(a(n.toDataURL(i,o))):e(n.mozGetAsFile("blob",i))})}:t.toDataURL&&a&&(t.toBlob=function(e,t,i){var o=this;setTimeout(function(){e(a(o.toDataURL(t,i)))})})),"function"==typeof define&&define.amd?define(function(){return a}):"object"==typeof module&&module.exports?module.exports=a:e.dataURLtoBlob=a}(window);